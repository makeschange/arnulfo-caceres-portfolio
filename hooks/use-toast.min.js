import*as React from"react";const TOAST_LIMIT=1,TOAST_REMOVE_DELAY=1e6;let count=0;function genId(){return count=(count+1)%Number.MAX_SAFE_INTEGER,count.toString()}const actionTypes={ADD_TOAST:"ADD_TOAST",UPDATE_TOAST:"UPDATE_TOAST",DISMISS_TOAST:"DISMISS_TOAST",REMOVE_TOAST:"REMOVE_TOAST"},toastTimeouts=new Map,addToRemoveQueue=toastId=>{if(toastTimeouts.has(toastId))return;const timeout=setTimeout(()=>{toastTimeouts.delete(toastId),dispatch({type:"REMOVE_TOAST",toastId:toastId})},1e6);toastTimeouts.set(toastId,timeout)};export const reducer=(state,action)=>{switch(action.type){case"ADD_TOAST":return{...state,toasts:[action.toast,...state.toasts].slice(0,1)};case"UPDATE_TOAST":return{...state,toasts:state.toasts.map(t=>t.id===action.toast.id?{...t,...action.toast}:t)};case"DISMISS_TOAST":{const{toastId:toastId}=action;return toastId?addToRemoveQueue(toastId):state.toasts.forEach(toast=>{addToRemoveQueue(toast.id)}),{...state,toasts:state.toasts.map(t=>t.id===toastId||void 0===toastId?{...t,open:!1}:t)}}case"REMOVE_TOAST":return void 0===action.toastId?{...state,toasts:[]}:{...state,toasts:state.toasts.filter(t=>t.id!==action.toastId)}}};const listeners=[];let memoryState={toasts:[]};function dispatch(action){memoryState=reducer(memoryState,action),listeners.forEach(listener=>{listener(memoryState)})}function toast({...props}){const id=genId(),update=props=>dispatch({type:"UPDATE_TOAST",toast:{...props,id:id}}),dismiss=()=>dispatch({type:"DISMISS_TOAST",toastId:id});return dispatch({type:"ADD_TOAST",toast:{...props,id:id,open:!0,onOpenChange:open=>{open||dismiss()}}}),{id:id,dismiss:dismiss,update:update}}function useToast(){const[state,setState]=React.useState(memoryState);return React.useEffect(()=>(listeners.push(setState),()=>{const index=listeners.indexOf(setState);index>-1&&listeners.splice(index,1)}),[state]),{...state,toast:toast,dismiss:toastId=>dispatch({type:"DISMISS_TOAST",toastId:toastId})}}export{useToast,toast};